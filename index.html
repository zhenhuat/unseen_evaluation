<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹-ç‰©äº¤äº’è¯„åˆ†ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .mode-toggle {
            text-align: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 10px 30px;
            margin: 0 10px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .evaluation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .method-card {
            border: 3px solid #ddd;
            border-radius: 15px;
            padding: 20px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .method-card.selected {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .method-card.affordpose {
            border-color: #e74c3c;
        }

        .method-card.affordpose.selected {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        .method-card.grabnet {
            border-color: #3498db;
        }

        .method-card.grabnet.selected {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .method-card.ragg {
            border-color: #2ecc71;
        }

        .method-card.ragg.selected {
            background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
        }

        .method-card.sns {
            border-color: #f39c12;
        }

        .method-card.sns.selected {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }

        .method-title {
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .method-card.affordpose .method-title {
            color: #e74c3c;
        }

        .method-card.grabnet .method-title {
            color: #3498db;
        }

        .method-card.ragg .method-title {
            color: #2ecc71;
        }

        .method-card.sns .method-title {
            color: #f39c12;
        }

        .model-viewer {
            width: 100%;
            height: 250px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            position: relative;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .model-status {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .status-loading {
            background: #ffeaa7;
            color: #2d3436;
        }

        .status-success {
            background: #00b894;
            color: white;
        }

        .status-error {
            background: #e74c3c;
            color: white;
        }

        .selection-checkbox {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .selection-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            cursor: pointer;
        }

        .selection-checkbox label {
            font-size: 1.1em;
            cursor: pointer;
            user-select: none;
        }

        .navigation {
            text-align: center;
            margin: 30px 0;
        }

        .nav-info {
            margin-bottom: 15px;
            font-size: 1.2em;
            color: #333;
        }

        .current-sample {
            font-weight: bold;
            color: #667eea;
        }

        .message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message.info {
            background: #cce5ff;
            color: #004085;
            border: 1px solid #99d6ff;
        }

        .results-section {
            margin-top: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
        }

        .chart-container {
            width: 100%;
            height: 400px;
            margin: 20px 0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: none;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: #333;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .help-section p {
            line-height: 1.6;
            color: #666;
            margin-bottom: 10px;
        }

        .keyboard-shortcuts {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
            margin: 10px 0;
        }

        .shortcut-key {
            background: #f0f0f0;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
        }

        .export-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
                border-radius: 10px;
            }

            .evaluation-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
            }

            .header h1 {
                font-size: 2em;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .stats {
                grid-template-columns: 1fr;
            }

            .mode-btn {
                padding: 8px 20px;
                margin: 5px;
            }
        }

        .model-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 5px;
            font-size: 0.7em;
            color: #666;
        }
    </style>

    <!-- Three.js æ ¸å¿ƒåº“ -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <!-- OBJ åŠ è½½å™¨ -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <!-- è½¨é“æ§åˆ¶å™¨ -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js å›¾è¡¨åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>3D æ‰‹-ç‰©äº¤äº’è¯„åˆ†ç³»ç»Ÿ</h1>
            <p>è¯„ä¼°å››ç§æ‰‹-ç‰©äº¤äº’æ–¹æ³•çš„æ€§èƒ½è¡¨ç°<br>
            æ ·æœ¬èŒƒå›´: 0-176  | éšæœºæŠ½å–: 20ä¸ªæ ·æœ¬</p>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="currentProgress">0</div>
                <div class="stat-label">å½“å‰è¿›åº¦</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalSamples">20</div>
                <div class="stat-label">æ€»æ ·æœ¬æ•°</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="evaluatedCount">0</div>
                <div class="stat-label">å·²è¯„ä¼°</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="elapsedTime">00:00</div>
                <div class="stat-label">ç”¨æ—¶</div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn btn-primary" onclick="startEvaluation()">å¼€å§‹è¯„ä¼°</button>
            <button class="control-btn btn-secondary" onclick="resetEvaluation()">é‡ç½®è¯„ä¼°</button>
            <button class="control-btn btn-success" onclick="showHelp()">ä½¿ç”¨å¸®åŠ©</button>
            <button class="control-btn btn-primary" onclick="exportResults('json')">å¯¼å‡ºJSON</button>
            <button class="control-btn btn-primary" onclick="exportResults('csv')">å¯¼å‡ºCSV</button>
        </div>

        <div class="mode-toggle">
            <button class="mode-btn active" onclick="switchMode('hold')">Hold æ¨¡å¼</button>
            <button class="mode-btn" onclick="switchMode('use')">Use æ¨¡å¼</button>
        </div>

        <div id="messageContainer"></div>

        <div class="evaluation-grid" id="evaluationGrid">
            <!-- åŠ¨æ€ç”Ÿæˆè¯„ä¼°å¡ç‰‡ -->
        </div>

        <div class="navigation" id="navigationSection" style="display: none;">
            <div class="nav-info">
                <span class="current-sample" id="currentSample">æ ·æœ¬ ID: -</span>
                <span id="sampleProgress">(- / -)</span>
            </div>
            <div class="controls">
                <button class="control-btn btn-secondary" onclick="previousSample()">ä¸Šä¸€ä¸ªæ ·æœ¬</button>
                <button class="control-btn btn-primary" onclick="nextSample()">ä¸‹ä¸€ä¸ªæ ·æœ¬</button>
                <button class="control-btn btn-success" onclick="skipSample()">è·³è¿‡æ ·æœ¬</button>
            </div>
        </div>

        <div class="results-section" id="resultsSection" style="display: none;">
            <h2 style="text-align: center; color: #333; margin-bottom: 20px;">è¯„ä¼°ç»“æœç»Ÿè®¡</h2>
            <div class="chart-container">
                <canvas id="resultsChart"></canvas>
            </div>
            <div id="detailedStats"></div>
        </div>
    </div>

    <!-- å¸®åŠ©æ¨¡æ€æ¡† -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeHelp()">&times;</span>
            <h2 style="color: #333; margin-bottom: 20px;">ä½¿ç”¨å¸®åŠ©</h2>

            <div class="help-section">
                <h3>è¯„ä¼°è¯´æ˜</h3>
                <p><strong>Hold æ¨¡å¼:</strong> è¯„ä¼°æ‰‹éƒ¨æ¡æŒç‰©ä½“çš„å§¿æ€ï¼Œå…³æ³¨ç¨³å®šæ€§å’Œè‡ªç„¶æ€§</p>
                <p><strong>Use æ¨¡å¼:</strong> è¯„ä¼°æ‰‹éƒ¨æ“ä½œç‰©ä½“çš„åŠŸèƒ½æ€§ï¼Œå…³æ³¨å¯ç”¨æ€§å’Œèˆ’é€‚åº¦</p>
            </div>

            <div class="help-section">
                <h3>æ“ä½œæµç¨‹</h3>
                <p>1. ç‚¹å‡»"å¼€å§‹è¯„ä¼°"å¼€å§‹è¯„ä¼°æµç¨‹</p>
                <p>2. é€‰æ‹©å½“å‰æ¨¡å¼ï¼ˆHold/Useï¼‰</p>
                <p>3. è§‚å¯Ÿå››ç§æ–¹æ³•çš„3Dæ‰‹-ç‰©ä½“äº¤äº’æ¨¡å‹</p>
                <p>4. é€‰æ‹©1-3ä¸ªè¡¨ç°æœ€ä½³çš„æ–¹æ³•</p>
                <p>5. ç‚¹å‡»"ä¸‹ä¸€ä¸ªæ ·æœ¬"ç»§ç»­</p>
            </div>

            <div class="help-section">
                <h3>3Dæ¨¡å‹æ§åˆ¶</h3>
                <p><strong>é¼ æ ‡å·¦é”®æ‹–æ‹½:</strong> æ—‹è½¬è§†è§’</p>
                <p><strong>é¼ æ ‡æ»šè½®:</strong> ç¼©æ”¾</p>
                <p><strong>é¼ æ ‡å³é”®æ‹–æ‹½:</strong> å¹³ç§»</p>
            </div>

            <div class="help-section">
                <h3>è¯„ä¼°æ ‡å‡†</h3>
                <p><strong>Holdæ¨¡å¼:</strong> æ‰‹éƒ¨æ¡æŒçš„ç¨³å®šæ€§ã€è‡ªç„¶æ€§ã€èˆ’é€‚åº¦</p>
                <p><strong>Useæ¨¡å¼:</strong> æ“ä½œçš„åŠŸèƒ½æ€§ã€ç²¾ç¡®åº¦ã€æ˜“ç”¨æ€§</p>
            </div>

            <div class="help-section">
                <h3>å¿«æ·é”®</h3>
                <div class="keyboard-shortcuts">
                    <span class="shortcut-key">ç©ºæ ¼</span>
                    <span>ä¸‹ä¸€ä¸ªæ ·æœ¬</span>
                    <span class="shortcut-key">S</span>
                    <span>è·³è¿‡å½“å‰æ ·æœ¬</span>
                    <span class="shortcut-key">H</span>
                    <span>åˆ‡æ¢åˆ°Holdæ¨¡å¼</span>
                    <span class="shortcut-key">U</span>
                    <span>åˆ‡æ¢åˆ°Useæ¨¡å¼</span>
                    <span class="shortcut-key">R</span>
                    <span>é‡ç½®è¯„ä¼°</span>
                    <span class="shortcut-key">?</span>
                    <span>æ˜¾ç¤ºå¸®åŠ©</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let currentSampleIndex = 0;
        let currentMode = 'hold';
        let samples = [];
        let evaluationResults = [];
        let isEvaluationActive = false;
        let evaluationStartTime = null;
        let timerInterval = null;
        let scenes = {};
        let cameras = {};
        let renderers = {};
        let controls = {};

        // æ–¹æ³•é…ç½®
        const methods = ['affordpose', 'grabnet', 'ragg', 'sns'];
        const methodColors = {
            affordpose: '#e74c3c',
            grabnet: '#3498db',
            ragg: '#2ecc71',
            sns: '#f39c12'
        };

        // ç”Ÿæˆéšæœºæ ·æœ¬ID
        function generateRandomSamples(count = 20) {
            const allIds = [];
            for (let i = 0; i <= 176; i++) {
                allIds.push(i);
            }

            // éšæœºæ‰“ä¹±å¹¶é€‰å–å‰countä¸ª
            const shuffled = allIds.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        // åˆå§‹åŒ–3Dåœºæ™¯
        class Model3DViewer {
            constructor(containerId, method) {
                this.containerId = containerId;
                this.method = method;
                this.container = document.getElementById(containerId);
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.currentModel = null;

                this.init();
            }

            init() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;

                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                // åˆ›å»ºç‰©ä½“
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(2, 2, 2);

                // åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ¸²æŸ“å™¨
                this.container.innerHTML = '';
                this.container.appendChild(this.renderer.domElement);

                // åˆ›å»ºæ§åˆ¶å™¨
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 10;

                // æ·»åŠ ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // æ·»åŠ ä¸»å…‰æº
<!--                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);-->
<!--                directionalLight.position.set(-10, -10, 5);-->
<!--                directionalLight.castShadow = true;-->
<!--                directionalLight.shadow.mapSize.width = 2048;-->
<!--                directionalLight.shadow.mapSize.height = 2048;-->
<!--                this.scene.add(directionalLight);-->

                // æ·»åŠ è¡¥å……å…‰æº
                const pointLight = new THREE.PointLight(0xffffff, 0.3);
                pointLight.position.set(-10, -10, -5);
                this.scene.add(pointLight);

                // æ·»åŠ åŠçƒå…‰ï¼ˆæ¨¡æ‹Ÿå¤©ç©ºå…‰ï¼‰
                const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.3);
                this.scene.add(hemisphereLight);

                // æ·»åŠ æ§åˆ¶æç¤º
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'model-controls';
                controlsDiv.innerHTML = 'å·¦é”®æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»';
                this.container.appendChild(controlsDiv);

                // å¯åŠ¨æ¸²æŸ“å¾ªç¯
                this.animate();

                // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                const handleResize = () => {
                    const newWidth = this.container.clientWidth;
                    const newHeight = this.container.clientHeight;
                    this.camera.aspect = newWidth / newHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(newWidth, newHeight);
                };
                window.addEventListener('resize', handleResize);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            async loadOBJModel(modelPath) {
                return new Promise((resolve, reject) => {
                    // å¼ºåˆ¶æ¸…é™¤ä¹‹å‰çš„æ¨¡å‹
                    if (this.currentModel) {
                        this.scene.remove(this.currentModel);
                        this.currentModel = null;
                    }

                    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                    this.showStatus('loading', `ğŸ”„ åŠ è½½æ–°æ ·æœ¬ä¸­...`);

                    // å¤„ç†æ–‡ä»¶è·¯å¾„
                    let finalPath = modelPath;
                    if (window.location.protocol === 'file:') {
                        finalPath = './' + modelPath;
                    }

                    console.log(`ğŸ¯ å¼ºåˆ¶åŠ è½½æ–°OBJæ–‡ä»¶: ${finalPath}`);

                    // ä½¿ç”¨æ ‡å‡†çš„THREE.OBJLoader
                    const loader = new THREE.OBJLoader();

                    loader.load(
                        finalPath,
                        // onLoad - æˆåŠŸåŠ è½½å›è°ƒ
                        (object) => {
                            console.log('âœ… OBJæ–‡ä»¶åŠ è½½æˆåŠŸ!');
                            this.processLoadedModel(object, modelPath);
                            this.showStatus('success', 'âœ… 3Dæ¨¡å‹åŠ è½½å®Œæˆ!');
                            setTimeout(() => this.hideStatus(), 3000);
                            resolve(object);
                        },
                        // onProgress - åŠ è½½è¿›åº¦å›è°ƒ
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percentage = Math.round((progress.loaded / progress.total) * 100);
                                this.showStatus('loading', `ğŸ”„ åŠ è½½è¿›åº¦: ${percentage}%`);
                                console.log('åŠ è½½è¿›åº¦:', percentage + '%');
                            }
                        },
                        // onError - é”™è¯¯å›è°ƒ
                        (error) => {
                            console.error('âŒ OBJæ–‡ä»¶åŠ è½½å¤±è´¥:', error);
                            console.error('æ–‡ä»¶è·¯å¾„:', finalPath);

                            // ç›´æ¥ä½¿ç”¨æ›¿ä»£æ¨¡å‹
                            this.showStatus('warning', 'ğŸ“¦ ä½¿ç”¨3Dæ›¿ä»£æ¨¡å‹');
                            this.createFallbackModel();

                            // è¿”å›æ›¿ä»£æ¨¡å‹ä½œä¸ºæˆåŠŸç»“æœ
                            setTimeout(() => resolve(this.currentModel), 1000);
                        }
                    );
                });
            }

            processLoadedModel(object, modelPath) {
                console.log('å¼€å§‹å¤„ç†åŠ è½½çš„OBJæ¨¡å‹...');

                // æ¸…é™¤ä¹‹å‰çš„æ¨¡å‹
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }

                // ç»Ÿè®¡æ¨¡å‹ä¿¡æ¯
                let meshCount = 0;
                let vertexCount = 0;

                // æ ¹æ®æ–¹æ³•ç¡®å®šåŸºç¡€é¢œè‰²
                let baseColor = 0x888888;
                if (modelPath.includes('affordpose')) baseColor = 0xe74c3c;
                else if (modelPath.includes('grabnet')) baseColor = 0x3498db;
                else if (modelPath.includes('ragg')) baseColor = 0x2ecc71;
                else if (modelPath.includes('sns')) baseColor = 0xf39c12;

                // ä¸ºæ¨¡å‹æ·»åŠ æè´¨å’Œå¤„ç†é¢œè‰²
                object.traverse((child) => {
                    if (child.isMesh) {
                        meshCount++;

                        // ç»Ÿè®¡é¡¶ç‚¹æ•°
                        if (child.geometry && child.geometry.attributes.position) {
                            vertexCount += child.geometry.attributes.position.count;
                        }

                        // åˆ›å»ºé«˜è´¨é‡æè´¨ - ä½¿ç”¨åŸºç¡€é¢œè‰²ä½†ç¨å¾®åå‘è‚‰è‰²
                        let materialColor = baseColor;
                        if (child.geometry && child.geometry.attributes.color) {
                            // å¦‚æœæœ‰é¡¶ç‚¹é¢œè‰²ï¼Œä½¿ç”¨è‚‰è‰²è°ƒ
                            materialColor = 0xfdbcb4; // è‚‰è‰²
                        }

                        child.material = new THREE.MeshLambertMaterial({
                            color: materialColor,
                            transparent: false,
                            opacity: 1.0,
                            side: THREE.DoubleSide,
                            wireframe: false,
                            vertexColors: child.geometry.attributes.color ? true : false
                        });

                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                console.log(`æ¨¡å‹ç»Ÿè®¡ - ç½‘æ ¼æ•°: ${meshCount}, é¡¶ç‚¹æ•°: ${vertexCount}`);

                // å±…ä¸­å’Œç¼©æ”¾æ¨¡å‹
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxSize = Math.max(size.x, size.y, size.z);
                console.log('æ¨¡å‹å°ºå¯¸:', size, 'æœ€å¤§å°ºå¯¸:', maxSize);

                if (maxSize > 0) {
                    const scale = 2.0 / maxSize;
                    object.scale.setScalar(scale);
                    object.position.copy(center).multiplyScalar(-scale);
                    console.log('æ¨¡å‹ç¼©æ”¾æ¯”ä¾‹:', scale);
                } else {
                    // å¦‚æœæ— æ³•è®¡ç®—å°ºå¯¸ï¼Œä½¿ç”¨é»˜è®¤ç¼©æ”¾
                    object.scale.setScalar(10);
                }

                // æ·»åŠ åˆ°åœºæ™¯
                this.scene.add(object);
                this.currentModel = object;

                console.log('âœ… OBJæ¨¡å‹å¤„ç†å®Œæˆå¹¶æ·»åŠ åˆ°åœºæ™¯');
            }

            showStatus(type, message) {
                let statusEl = this.container.querySelector('.model-status');
                if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.className = 'model-status';
                    this.container.appendChild(statusEl);
                }

                statusEl.className = `model-status status-${type}`;
                statusEl.textContent = message;
                statusEl.style.display = 'block';
            }

            hideStatus() {
                const statusEl = this.container.querySelector('.model-status');
                if (statusEl) {
                    statusEl.style.display = 'none';
                }
            }

            createFallbackModel() {
                // æ¸…é™¤ä¹‹å‰çš„æ¨¡å‹
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }

                // åˆ›å»ºæ–¹æ³•é¢œè‰²
                let methodColor = 0x888888;
                if (this.method === 'affordpose') methodColor = 0xe74c3c;
                else if (this.method === 'grabnet') methodColor = 0x3498db;
                else if (this.method === 'ragg') methodColor = 0x2ecc71;
                else if (this.method === 'sns') methodColor = 0xf39c12;

                const group = new THREE.Group();

                // åˆ›å»ºç®€åŒ–çš„æ‰‹éƒ¨æ¨¡å‹
                // const handMaterial = new THREE.MeshPhongMaterial({ color: 0xfdbcb4 });
                const handMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbd0 });

                // æ‰‹æŒ
                const palmGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.5);
                const palm = new THREE.Mesh(palmGeometry, handMaterial);
                palm.position.set(0, 0, 0);
                group.add(palm);

                // æ‰‹æŒ‡
                for (let i = 0; i < 5; i++) {
                    const fingerGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.2);
                    const finger = new THREE.Mesh(fingerGeometry, handMaterial);
                    finger.position.set(-0.12 + i * 0.06, 0.05, 0.35);
                    group.add(finger);
                }

                // åˆ›å»ºç‰©ä½“æ¨¡å‹
                const cameraMaterial = new THREE.MeshPhongMaterial({ color: methodColor });

                // ç‰©ä½“ä¸»ä½“
                const cameraBodyGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.2);
                const cameraBody = new THREE.Mesh(cameraBodyGeometry, cameraMaterial);

                if (currentMode === 'hold') {
                    cameraBody.position.set(0, 0.15, -0.1);
                    cameraBody.rotation.x = -Math.PI / 6;
                } else {
                    cameraBody.position.set(0.2, 0.1, 0.1);
                    cameraBody.rotation.y = Math.PI / 4;
                }

                group.add(cameraBody);

                // é•œå¤´
                const lensGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.1);
                // const lensMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const lensMaterial = new THREE.MeshPhongMaterial({ color: 0x1a237e });
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);

                if (currentMode === 'hold') {
                    lens.position.set(0, 0.15, 0.05);
                    lens.rotation.x = Math.PI / 2;
                } else {
                    lens.position.set(0.35, 0.1, 0.1);
                    lens.rotation.z = Math.PI / 2;
                }

                group.add(lens);

                // æ·»åŠ é˜´å½±
                group.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                this.scene.add(group);
                this.currentModel = group;

                if (window.location.protocol === 'file:') {
                    this.showStatus('success', `âœ¨ ${this.method.toUpperCase()} æ–¹æ³•3Dæ¨¡å‹`);
                } else {
                    this.showStatus('error', `ğŸŸ¡ æ˜¾ç¤º ${this.method.toUpperCase()} æ–¹æ³•æ›¿ä»£æ¨¡å‹`);
                }

                // 5ç§’åéšè—çŠ¶æ€
                setTimeout(() => {
                    this.hideStatus();
                }, 5000);
            }
        }

        // åˆå§‹åŒ–è¯„ä¼°ç³»ç»Ÿ
        function initializeEvaluation() {
            samples = generateRandomSamples(20);
            currentSampleIndex = 0;
            evaluationResults = [];
            isEvaluationActive = false;

            showMessage('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼ç‚¹å‡»"å¼€å§‹è¯„ä¼°"å¼€å§‹æ‰‹-ç‰©ä½“äº¤äº’è¯„ä¼°ã€‚', 'info');

            // åˆ›å»ºè¯„ä¼°ç½‘æ ¼
            createEvaluationGrid();
        }

        // åˆ›å»ºè¯„ä¼°ç½‘æ ¼
        function createEvaluationGrid() {
            const grid = document.getElementById('evaluationGrid');
            grid.innerHTML = '';

            methods.forEach(method => {
                const card = document.createElement('div');
                card.className = `method-card ${method}`;
                card.innerHTML = `
                    <div class="method-title">${method.toUpperCase()}</div>
                    <div class="model-viewer" id="viewer-${method}">
                        <div class="loading-spinner" style="display: none;"></div>
                    </div>
                    <div class="selection-checkbox">
                        <input type="checkbox" id="checkbox-${method}" onchange="handleMethodSelection('${method}')">
                        <label for="checkbox-${method}">é€‰æ‹©</label>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        // å¼€å§‹è¯„ä¼°
        function startEvaluation() {
            if (samples.length === 0) {
                showMessage('è¯·å…ˆåˆå§‹åŒ–è¯„ä¼°ç³»ç»Ÿï¼', 'error');
                return;
            }

            isEvaluationActive = true;
            evaluationStartTime = Date.now();
            currentSampleIndex = 0;

            // æ˜¾ç¤ºå¯¼èˆªåŒºåŸŸ
            document.getElementById('navigationSection').style.display = 'block';

            // å¯åŠ¨è®¡æ—¶å™¨
            startTimer();

            // åŠ è½½ç¬¬ä¸€ä¸ªæ ·æœ¬
            loadCurrentSample();

            showMessage('è¯„ä¼°å·²å¼€å§‹ï¼è§‚å¯Ÿæ‰‹-ç‰©ä½“äº¤äº’æ¨¡å‹å¹¶é€‰æ‹©è¡¨ç°æœ€ä½³çš„æ–¹æ³•ã€‚', 'success');
        }

        // åŠ è½½å½“å‰æ ·æœ¬
        async function loadCurrentSample() {
            if (currentSampleIndex >= samples.length) {
                completeEvaluation();
                return;
            }

            const sampleId = samples[currentSampleIndex];
            const paddedId = String(sampleId).padStart(4, '0');
            console.log(`ğŸ”„ åŠ è½½æ ·æœ¬ ${sampleId} (${currentMode}æ¨¡å¼)`);
            updateUI();
            
            // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
            methods.forEach(method => {
                const checkbox = document.getElementById(`checkbox-${method}`);
                const card = checkbox.closest('.method-card');
                checkbox.checked = false;
                card.classList.remove('selected');
            });
            
            // å¼ºåˆ¶é‡æ–°åˆ›å»ºæ‰€æœ‰3DæŸ¥çœ‹å™¨ï¼Œç¡®ä¿åŠ è½½æ–°æ¨¡å‹
            window.viewers = {};
            
            // ä¸ºæ¯ä¸ªæ–¹æ³•åŠ è½½3Dæ¨¡å‹
            const promises = methods.map(async method => {
                const viewerId = `viewer-${method}`;
                const modelPath = `viz_mesh/${method}/${currentMode}/sample_${paddedId}.obj`;
                
                console.log(`ğŸ¯ æ­£åœ¨åŠ è½½ ${method} æ ·æœ¬ ${sampleId}:`, modelPath);
                
                // æ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„3DæŸ¥çœ‹å™¨
                if (!window.viewers) window.viewers = {};
                window.viewers[viewerId] = new Model3DViewer(viewerId, method);
                
                const viewer = window.viewers[viewerId];
                
                try {
                    await viewer.loadOBJModel(modelPath);
                    console.log(`âœ… ${method} æ ·æœ¬ ${sampleId} åŠ è½½æˆåŠŸ`);
                } catch (error) {
                    console.warn(`âš ï¸ ${method} æ ·æœ¬ ${sampleId} åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ›¿ä»£æ¨¡å‹`);
                }
            });
            
            // ç­‰å¾…æ‰€æœ‰æ¨¡å‹åŠ è½½å®Œæˆ
            try {
                const results = await Promise.allSettled(promises);
                const failedCount = results.filter(r => r.status === 'rejected').length;
                
                if (failedCount === 0) {
                    showMessage(`ğŸ‰ æ ·æœ¬ ${sampleId} (${currentMode}æ¨¡å¼) å·²åŠ è½½å®Œæˆï¼æ‰€æœ‰æ¨¡å‹éƒ½æ˜¯æ–°çš„ï¼`, 'success');
                } else if (failedCount === methods.length) {
                    if (window.location.protocol === 'file:') {
                        showMessage(`ğŸ”„ æ ·æœ¬ ${sampleId} å·²æ›´æ–°ï¼ä½¿ç”¨3Dæ›¿ä»£æ¨¡å‹æ˜¾ç¤º`, 'info');
                    } else {
                        showMessage(`ğŸ”„ æ ·æœ¬ ${sampleId} å·²æ›´æ–°ï¼ä½¿ç”¨æ›¿ä»£æ¨¡å‹æ˜¾ç¤º`, 'warning');
                    }
                } else {
                    showMessage(`ğŸ”„ æ ·æœ¬ ${sampleId} å·²æ›´æ–°ï¼éƒ¨åˆ†ä½¿ç”¨æ›¿ä»£æ¨¡å‹`, 'warning');
                }
                
                // è®©ç”¨æˆ·æ˜ç¡®çŸ¥é“æ ·æœ¬å·²ç»æ›´æ¢
                console.log(`âœ… æ ·æœ¬åˆ‡æ¢å®Œæˆï¼å½“å‰æ˜¾ç¤ºæ ·æœ¬ ${sampleId}`);
                
            } catch (error) {
                showMessage(`âŒ æ ·æœ¬ ${sampleId} åŠ è½½å‡ºé”™`, 'error');
            }
        }

        // å¤„ç†æ–¹æ³•é€‰æ‹©
        function handleMethodSelection(method) {
            const checkbox = document.getElementById(`checkbox-${method}`);
            const card = checkbox.closest('.method-card');
            
            if (checkbox.checked) {
                card.classList.add('selected');
                
                // æ£€æŸ¥é€‰æ‹©æ•°é‡é™åˆ¶
                const selectedCount = document.querySelectorAll('.method-card.selected').length;
                if (selectedCount > 3) {
                    checkbox.checked = false;
                    card.classList.remove('selected');
                    showMessage('æœ€å¤šåªèƒ½é€‰æ‹©3ä¸ªæ–¹æ³•ï¼', 'warning');
                }
            } else {
                card.classList.remove('selected');
            }
        }

        // ä¸‹ä¸€ä¸ªæ ·æœ¬
        function nextSample() {
            if (!isEvaluationActive) {
                showMessage('è¯·å…ˆå¼€å§‹è¯„ä¼°ï¼', 'warning');
                return;
            }
            
            const selectedMethods = Array.from(document.querySelectorAll('.method-card.selected'))
                .map(card => card.classList[1]);
            
            if (selectedMethods.length === 0) {
                showMessage('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ–¹æ³•ï¼', 'warning');
                return;
            }
            
            // ä¿å­˜å½“å‰æ ·æœ¬çš„è¯„ä¼°ç»“æœ
            const sampleId = samples[currentSampleIndex];
            evaluationResults.push({
                sampleId: sampleId,
                mode: currentMode,
                selectedMethods: selectedMethods,
                timestamp: new Date().toISOString(),
                evaluationTime: Date.now() - evaluationStartTime
            });
            
            currentSampleIndex++;
            loadCurrentSample();
        }

        // ä¸Šä¸€ä¸ªæ ·æœ¬
        function previousSample() {
            if (currentSampleIndex > 0) {
                currentSampleIndex--;
                
                // ç§»é™¤ä¸Šä¸€ä¸ªæ ·æœ¬çš„ç»“æœ
                evaluationResults = evaluationResults.filter(result => 
                    result.sampleId !== samples[currentSampleIndex] || result.mode !== currentMode
                );
                
                loadCurrentSample();
            }
        }

        // è·³è¿‡æ ·æœ¬
        function skipSample() {
            if (!isEvaluationActive) return;
            
            const sampleId = samples[currentSampleIndex];
            evaluationResults.push({
                sampleId: sampleId,
                mode: currentMode,
                selectedMethods: [],
                skipped: true,
                timestamp: new Date().toISOString(),
                evaluationTime: Date.now() - evaluationStartTime
            });
            
            currentSampleIndex++;
            loadCurrentSample();
            
            showMessage('æ ·æœ¬å·²è·³è¿‡', 'info');
        }

        // åˆ‡æ¢æ¨¡å¼
        function switchMode(mode) {
            if (currentMode === mode) return;
            
            currentMode = mode;
            
            // æ›´æ–°æ¨¡å¼æŒ‰é’®
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // å¦‚æœè¯„ä¼°æ´»è·ƒï¼Œé‡æ–°åŠ è½½å½“å‰æ ·æœ¬
            if (isEvaluationActive) {
                loadCurrentSample();
            }
            
            showMessage(`å·²åˆ‡æ¢åˆ° ${mode.toUpperCase()} æ¨¡å¼`, 'info');
        }

        // æ›´æ–°UI
        function updateUI() {
            const sampleId = samples[currentSampleIndex];
            document.getElementById('currentSample').textContent = `æ ·æœ¬ ID: ${sampleId}`;
            document.getElementById('sampleProgress').textContent = `(${currentSampleIndex + 1} / ${samples.length})`;
            document.getElementById('currentProgress').textContent = `${currentSampleIndex + 1}/${samples.length}`;
            document.getElementById('evaluatedCount').textContent = evaluationResults.length;
            
            const progress = (currentSampleIndex / samples.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        // å¯åŠ¨è®¡æ—¶å™¨
        function startTimer() {
            timerInterval = setInterval(() => {
                if (evaluationStartTime) {
                    const elapsed = Date.now() - evaluationStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('elapsedTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        // å®Œæˆè¯„ä¼°
        function completeEvaluation() {
            isEvaluationActive = false;
            clearInterval(timerInterval);
            
            // éšè—å¯¼èˆªåŒºåŸŸ
            document.getElementById('navigationSection').style.display = 'none';
            
            // æ˜¾ç¤ºç»“æœ
            showResults();
            
            showMessage('ğŸ‰ è¯„ä¼°å®Œæˆï¼æŸ¥çœ‹ä¸‹æ–¹çš„è¯¦ç»†ç»Ÿè®¡ç»“æœã€‚', 'success');
        }

        // æ˜¾ç¤ºç»“æœ
        function showResults() {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            
            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            const stats = calculateStatistics();
            
            // åˆ›å»ºå›¾è¡¨
            createResultsChart(stats);
            
            // æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
            displayDetailedStats(stats);
        }

        // è®¡ç®—ç»Ÿè®¡æ•°æ®
        function calculateStatistics() {
            const methodStats = {};
            const modeStats = { hold: {}, use: {} };
            
            methods.forEach(method => {
                methodStats[method] = { total: 0, hold: 0, use: 0 };
                modeStats.hold[method] = 0;
                modeStats.use[method] = 0;
            });
            
            evaluationResults.forEach(result => {
                if (!result.skipped) {
                    result.selectedMethods.forEach(method => {
                        methodStats[method].total++;
                        methodStats[method][result.mode]++;
                        modeStats[result.mode][method]++;
                    });
                }
            });
            
            return { methodStats, modeStats };
        }

        // åˆ›å»ºç»“æœå›¾è¡¨
        function createResultsChart(stats) {
            const ctx = document.getElementById('resultsChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: methods.map(m => m.toUpperCase()),
                    datasets: [
                        {
                            label: 'Hold æ¨¡å¼é€‰æ‹©æ¬¡æ•°',
                            data: methods.map(method => stats.modeStats.hold[method]),
                            backgroundColor: 'rgba(102, 126, 234, 0.8)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Use æ¨¡å¼é€‰æ‹©æ¬¡æ•°',
                            data: methods.map(method => stats.modeStats.use[method]),
                            backgroundColor: 'rgba(118, 75, 162, 0.8)',
                            borderColor: 'rgba(118, 75, 162, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            stepSize: 1
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'å„æ–¹æ³•åœ¨ä¸åŒæ¨¡å¼ä¸‹çš„é€‰æ‹©ç»Ÿè®¡'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
        function displayDetailedStats(stats) {
            const detailedStats = document.getElementById('detailedStats');
            
            let html = '<h3>è¯¦ç»†ç»Ÿè®¡æ•°æ®</h3>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">';
            
            methods.forEach(method => {
                const methodStat = stats.methodStats[method];
                const percentage = ((methodStat.total / evaluationResults.filter(r => !r.skipped).length) * 100).toFixed(1);
                
                html += `
                    <div style="background: ${methodColors[method]}20; padding: 15px; border-radius: 10px; border-left: 4px solid ${methodColors[method]};">
                        <h4 style="color: ${methodColors[method]}; margin-bottom: 10px;">${method.toUpperCase()}</h4>
                        <p>æ€»é€‰æ‹©æ¬¡æ•°: <strong>${methodStat.total}</strong></p>
                        <p>Holdæ¨¡å¼: <strong>${methodStat.hold}</strong></p>
                        <p>Useæ¨¡å¼: <strong>${methodStat.use}</strong></p>
                        <p>é€‰æ‹©ç‡: <strong>${percentage}%</strong></p>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // æ·»åŠ è¯„ä¼°æ¦‚è§ˆ
            const totalEvaluated = evaluationResults.filter(r => !r.skipped).length;
            const totalSkipped = evaluationResults.filter(r => r.skipped).length;
            const avgSelections = (evaluationResults.filter(r => !r.skipped).reduce((sum, r) => sum + r.selectedMethods.length, 0) / totalEvaluated).toFixed(1);
            
            html += `
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h4>è¯„ä¼°æ¦‚è§ˆ</h4>
                    <p>æ€»æ ·æœ¬æ•°: <strong>${samples.length}</strong></p>
                    <p>å·²è¯„ä¼°: <strong>${totalEvaluated}</strong></p>
                    <p>å·²è·³è¿‡: <strong>${totalSkipped}</strong></p>
                    <p>å¹³å‡æ¯æ ·æœ¬é€‰æ‹©æ–¹æ³•æ•°: <strong>${avgSelections}</strong></p>
                    <p>è¯„ä¼°æ€»æ—¶é•¿: <strong>${document.getElementById('elapsedTime').textContent}</strong></p>
                </div>
            `;
            
            detailedStats.innerHTML = html;
        }

        // å¯¼å‡ºç»“æœ
        function exportResults(format) {
            if (evaluationResults.length === 0) {
                showMessage('æ²¡æœ‰å¯å¯¼å‡ºçš„è¯„ä¼°ç»“æœï¼', 'warning');
                return;
            }
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const filename = `hand_camera_interaction_evaluation_${timestamp}`;
            
            if (format === 'json') {
                const data = {
                    metadata: {
                        evaluationDate: new Date().toISOString(),
                        totalSamples: samples.length,
                        evaluatedSamples: evaluationResults.filter(r => !r.skipped).length,
                        skippedSamples: evaluationResults.filter(r => r.skipped).length,
                        modes: ['hold', 'use'],
                        methods: methods,
                        sampleRange: '0-176'
                    },
                    samples: samples,
                    results: evaluationResults,
                    statistics: calculateStatistics()
                };
                
                downloadJSON(data, `${filename}.json`);
            } else if (format === 'csv') {
                const csvContent = generateCSV();
                downloadCSV(csvContent, `${filename}.csv`);
            }
            
            showMessage(`è¯„ä¼°ç»“æœå·²å¯¼å‡ºä¸º ${format.toUpperCase()} æ ¼å¼ï¼`, 'success');
        }

        // ç”ŸæˆCSVå†…å®¹
        function generateCSV() {
            let csv = 'Sample ID,Mode,Selected Methods,Skipped,Timestamp,Evaluation Time (ms)\n';
            
            evaluationResults.forEach(result => {
                const selectedMethods = result.selectedMethods.join(';');
                csv += `${result.sampleId},${result.mode},"${selectedMethods}",${result.skipped || false},${result.timestamp},${result.evaluationTime}\n`;
            });
            
            return csv;
        }

        // ä¸‹è½½JSONæ–‡ä»¶
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ä¸‹è½½CSVæ–‡ä»¶
        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // é‡ç½®è¯„ä¼°
        function resetEvaluation() {
            if (isEvaluationActive && !confirm('ç¡®å®šè¦é‡ç½®å½“å‰è¯„ä¼°å—ï¼Ÿæ‰€æœ‰è¿›åº¦å°†ä¸¢å¤±ï¼')) {
                return;
            }
            
            // æ¸…ç†çŠ¶æ€
            isEvaluationActive = false;
            clearInterval(timerInterval);
            currentSampleIndex = 0;
            evaluationResults = [];
            evaluationStartTime = null;
            
            // é‡ç½®UI
            document.getElementById('navigationSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('currentProgress').textContent = '0';
            document.getElementById('evaluatedCount').textContent = '0';
            document.getElementById('elapsedTime').textContent = '00:00';
            document.getElementById('progressFill').style.width = '0%';
            
            // æ¸…é™¤é€‰æ‹©
            document.querySelectorAll('.method-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // é‡æ–°åˆå§‹åŒ–
            initializeEvaluation();
            
            showMessage('è¯„ä¼°å·²é‡ç½®ï¼å¯ä»¥é‡æ–°å¼€å§‹è¯„ä¼°ã€‚', 'info');
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(text, type = 'info') {
            const container = document.getElementById('messageContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            
            container.innerHTML = '';
            container.appendChild(messageDiv);
            
            // 5ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // æ˜¾ç¤ºå¸®åŠ©
        function showHelp() {
            document.getElementById('helpModal').style.display = 'block';
        }

        // å…³é—­å¸®åŠ©
        function closeHelp() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(event) {
            if (!isEvaluationActive) return;
            
            switch(event.key) {
                case ' ':
                    event.preventDefault();
                    nextSample();
                    break;
                case 's':
                case 'S':
                    event.preventDefault();
                    skipSample();
                    break;
                case 'h':
                case 'H':
                    event.preventDefault();
                    switchMode('hold');
                    break;
                case 'u':
                case 'U':
                    event.preventDefault();
                    switchMode('use');
                    break;
                case 'r':
                case 'R':
                    event.preventDefault();
                    resetEvaluation();
                    break;
                case '?':
                    event.preventDefault();
                    showHelp();
                    break;
            }
        });

        // æ¨¡æ€æ¡†ç‚¹å‡»å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('helpModal');
            if (event.target === modal) {
                closeHelp();
            }
        }





        // é¡µé¢åŠ è½½å®Œæˆåè¿è¡Œè¯Šæ–­
        document.addEventListener('DOMContentLoaded', function() {
            runSystemDiagnostics();
            initializeEvaluation();
        });

        // ç³»ç»Ÿè¯Šæ–­åŠŸèƒ½
        async function runSystemDiagnostics() {
            console.log('ğŸ” å¼€å§‹ç³»ç»Ÿè¯Šæ–­...');
            
            // æ£€æŸ¥Three.jsåŠ è½½çŠ¶æ€
            if (typeof THREE !== 'undefined') {
                console.log('âœ… Three.jsåº“åŠ è½½æˆåŠŸ');
                showMessage('âœ… Three.jså¼•æ“åŠ è½½æˆåŠŸ', 'success');
            } else {
                console.error('âŒ Three.jsåº“åŠ è½½å¤±è´¥');
                showMessage('âŒ Three.jså¼•æ“åŠ è½½å¤±è´¥', 'error');
                return;
            }
            
            // æ£€æŸ¥OBJåŠ è½½å™¨
            if (typeof THREE.OBJLoader !== 'undefined') {
                console.log('âœ… OBJLoaderåŠ è½½æˆåŠŸ');
            } else {
                console.error('âŒ OBJLoaderåŠ è½½å¤±è´¥');
                showMessage('âŒ OBJåŠ è½½å™¨æ— æ³•ä½¿ç”¨', 'error');
                return;
            }
            
            // æ£€æŸ¥è½¨é“æ§åˆ¶å™¨
            if (typeof THREE.OrbitControls !== 'undefined') {
                console.log('âœ… OrbitControlsåŠ è½½æˆåŠŸ');
            } else {
                console.error('âŒ OrbitControlsåŠ è½½å¤±è´¥');
                showMessage('âŒ 3Dæ§åˆ¶å™¨æ— æ³•ä½¿ç”¨', 'warning');
            }
            
            // æµ‹è¯•OBJæ–‡ä»¶è®¿é—®
            await testOBJAccess();
            
            console.log('ğŸ¯ ç³»ç»Ÿè¯Šæ–­å®Œæˆ');
        }

        // æµ‹è¯•OBJæ–‡ä»¶è®¿é—®
        async function testOBJAccess() {
            const testFile = 'viz_mesh/affordpose/hold/sample_2065.obj';
            
            try {
                console.log('ğŸ” æµ‹è¯•OBJæ–‡ä»¶è®¿é—®:', testFile);
                
                const response = await fetch(testFile);
                if (response.ok) {
                    const text = await response.text();
                    if (text.length > 100 && text.includes('v ')) {
                        console.log('âœ… OBJæ–‡ä»¶è®¿é—®æµ‹è¯•é€šè¿‡ï¼');
                        showMessage('âœ… OBJæ–‡ä»¶è®¿é—®æµ‹è¯•é€šè¿‡ï¼å¯ä»¥æ­£å¸¸åŠ è½½3Dæ¨¡å‹', 'success');
                        return true;
                    } else {
                        console.log('âš ï¸ OBJæ–‡ä»¶æ ¼å¼å¼‚å¸¸');
                        showMessage('âš ï¸ OBJæ–‡ä»¶æ ¼å¼å¯èƒ½æœ‰é—®é¢˜', 'warning');
                    }
                } else {
                    console.log('âŒ OBJæ–‡ä»¶è®¿é—®å¤±è´¥:', response.status);
                    showMessage('ğŸŸ¡ OBJæ–‡ä»¶è®¿é—®å—é™ï¼Œå°†ä½¿ç”¨3Dæ›¿ä»£æ¨¡å‹', 'info');
                }
            } catch (error) {
                console.log('âŒ OBJæ–‡ä»¶è®¿é—®é”™è¯¯:', error.message);
                if (window.location.protocol === 'file:') {
                    showMessage('ğŸŒŸ ç›´æ¥æ–‡ä»¶æ¨¡å¼å¯åŠ¨æˆåŠŸï¼ç³»ç»Ÿå°†ä½¿ç”¨æ™ºèƒ½3Dæ¨¡å‹æ˜¾ç¤º', 'info');
                } else {
                    showMessage('ğŸŸ¡ ä½¿ç”¨3Dæ›¿ä»£æ¨¡å‹ç¡®ä¿è¯„ä¼°åŠŸèƒ½æ­£å¸¸', 'info');
                }
            }
            return false;
        }
    </script>
</body>
</html> 
