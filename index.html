<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 手-物交互评分系统</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .mode-toggle {
            text-align: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 10px 30px;
            margin: 0 10px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .evaluation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .method-card {
            border: 3px solid #ddd;
            border-radius: 15px;
            padding: 20px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .method-card.selected {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .method-card.affordpose {
            border-color: #e74c3c;
        }

        .method-card.affordpose.selected {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        .method-card.grabnet {
            border-color: #3498db;
        }

        .method-card.grabnet.selected {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .method-card.ragg {
            border-color: #2ecc71;
        }

        .method-card.ragg.selected {
            background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
        }

        .method-card.sns {
            border-color: #f39c12;
        }

        .method-card.sns.selected {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        }

        .method-title {
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .method-card.affordpose .method-title {
            color: #e74c3c;
        }

        .method-card.grabnet .method-title {
            color: #3498db;
        }

        .method-card.ragg .method-title {
            color: #2ecc71;
        }

        .method-card.sns .method-title {
            color: #f39c12;
        }

        .model-viewer {
            width: 100%;
            height: 250px;
            border: 2px dashed #ddd;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            position: relative;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .model-status {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .status-loading {
            background: #ffeaa7;
            color: #2d3436;
        }

        .status-success {
            background: #00b894;
            color: white;
        }

        .status-error {
            background: #e74c3c;
            color: white;
        }

        .selection-checkbox {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .selection-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            cursor: pointer;
        }

        .selection-checkbox label {
            font-size: 1.1em;
            cursor: pointer;
            user-select: none;
        }

        .navigation {
            text-align: center;
            margin: 30px 0;
        }

        .nav-info {
            margin-bottom: 15px;
            font-size: 1.2em;
            color: #333;
        }

        .current-sample {
            font-weight: bold;
            color: #667eea;
        }

        .message {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .message.info {
            background: #cce5ff;
            color: #004085;
            border: 1px solid #99d6ff;
        }

        .results-section {
            margin-top: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
        }

        .chart-container {
            width: 100%;
            height: 400px;
            margin: 20px 0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: none;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: #333;
            margin-bottom: 10px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .help-section p {
            line-height: 1.6;
            color: #666;
            margin-bottom: 10px;
        }

        .keyboard-shortcuts {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
            margin: 10px 0;
        }

        .shortcut-key {
            background: #f0f0f0;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
        }

        .export-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
                border-radius: 10px;
            }

            .evaluation-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                flex-direction: column;
            }

            .header h1 {
                font-size: 2em;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .stats {
                grid-template-columns: 1fr;
            }

            .mode-btn {
                padding: 8px 20px;
                margin: 5px;
            }
        }

        .model-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 5px;
            font-size: 0.7em;
            color: #666;
        }
    </style>

    <!-- Three.js 核心库 -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <!-- OBJ 加载器 -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <!-- 轨道控制器 -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js 图表库 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>3D 手-物交互评分系统</h1>
            <p>评估四种手-物交互方法的性能表现<br>
            样本范围: 0-176  | 随机抽取: 20个样本</p>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="currentProgress">0</div>
                <div class="stat-label">当前进度</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalSamples">20</div>
                <div class="stat-label">总样本数</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="evaluatedCount">0</div>
                <div class="stat-label">已评估</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="elapsedTime">00:00</div>
                <div class="stat-label">用时</div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn btn-primary" onclick="startEvaluation()">开始评估</button>
            <button class="control-btn btn-secondary" onclick="resetEvaluation()">重置评估</button>
            <button class="control-btn btn-success" onclick="showHelp()">使用帮助</button>
            <button class="control-btn btn-primary" onclick="exportResults('json')">导出JSON</button>
            <button class="control-btn btn-primary" onclick="exportResults('csv')">导出CSV</button>
        </div>

        <div class="mode-toggle">
            <button class="mode-btn active" onclick="switchMode('hold')">Hold 模式</button>
            <button class="mode-btn" onclick="switchMode('use')">Use 模式</button>
        </div>

        <div id="messageContainer"></div>

        <div class="evaluation-grid" id="evaluationGrid">
            <!-- 动态生成评估卡片 -->
        </div>

        <div class="navigation" id="navigationSection" style="display: none;">
            <div class="nav-info">
                <span class="current-sample" id="currentSample">样本 ID: -</span>
                <span id="sampleProgress">(- / -)</span>
            </div>
            <div class="controls">
                <button class="control-btn btn-secondary" onclick="previousSample()">上一个样本</button>
                <button class="control-btn btn-primary" onclick="nextSample()">下一个样本</button>
                <button class="control-btn btn-success" onclick="skipSample()">跳过样本</button>
            </div>
        </div>

        <div class="results-section" id="resultsSection" style="display: none;">
            <h2 style="text-align: center; color: #333; margin-bottom: 20px;">评估结果统计</h2>
            <div class="chart-container">
                <canvas id="resultsChart"></canvas>
            </div>
            <div id="detailedStats"></div>
        </div>
    </div>

    <!-- 帮助模态框 -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeHelp()">&times;</span>
            <h2 style="color: #333; margin-bottom: 20px;">使用帮助</h2>

            <div class="help-section">
                <h3>评估说明</h3>
                <p><strong>Hold 模式:</strong> 评估手部握持物体的姿态，关注稳定性和自然性</p>
                <p><strong>Use 模式:</strong> 评估手部操作物体的功能性，关注可用性和舒适度</p>
            </div>

            <div class="help-section">
                <h3>操作流程</h3>
                <p>1. 点击"开始评估"开始评估流程</p>
                <p>2. 选择当前模式（Hold/Use）</p>
                <p>3. 观察四种方法的3D手-物体交互模型</p>
                <p>4. 选择1-3个表现最佳的方法</p>
                <p>5. 点击"下一个样本"继续</p>
            </div>

            <div class="help-section">
                <h3>3D模型控制</h3>
                <p><strong>鼠标左键拖拽:</strong> 旋转视角</p>
                <p><strong>鼠标滚轮:</strong> 缩放</p>
                <p><strong>鼠标右键拖拽:</strong> 平移</p>
            </div>

            <div class="help-section">
                <h3>评估标准</h3>
                <p><strong>Hold模式:</strong> 手部握持的稳定性、自然性、舒适度</p>
                <p><strong>Use模式:</strong> 操作的功能性、精确度、易用性</p>
            </div>

            <div class="help-section">
                <h3>快捷键</h3>
                <div class="keyboard-shortcuts">
                    <span class="shortcut-key">空格</span>
                    <span>下一个样本</span>
                    <span class="shortcut-key">S</span>
                    <span>跳过当前样本</span>
                    <span class="shortcut-key">H</span>
                    <span>切换到Hold模式</span>
                    <span class="shortcut-key">U</span>
                    <span>切换到Use模式</span>
                    <span class="shortcut-key">R</span>
                    <span>重置评估</span>
                    <span class="shortcut-key">?</span>
                    <span>显示帮助</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let currentSampleIndex = 0;
        let currentMode = 'hold';
        let samples = [];
        let evaluationResults = [];
        let isEvaluationActive = false;
        let evaluationStartTime = null;
        let timerInterval = null;
        let scenes = {};
        let cameras = {};
        let renderers = {};
        let controls = {};

        // 方法配置
        const methods = ['affordpose', 'grabnet', 'ragg', 'sns'];
        const methodColors = {
            affordpose: '#e74c3c',
            grabnet: '#3498db',
            ragg: '#2ecc71',
            sns: '#f39c12'
        };

        // 生成随机样本ID
        function generateRandomSamples(count = 20) {
            const allIds = [];
            for (let i = 0; i <= 176; i++) {
                allIds.push(i);
            }

            // 随机打乱并选取前count个
            const shuffled = allIds.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        // 初始化3D场景
        class Model3DViewer {
            constructor(containerId, method) {
                this.containerId = containerId;
                this.method = method;
                this.container = document.getElementById(containerId);
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.currentModel = null;

                this.init();
            }

            init() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;

                // 创建场景
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                // 创建物体
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(2, 2, 2);

                // 创建渲染器
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(width, height);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // 清空容器并添加渲染器
                this.container.innerHTML = '';
                this.container.appendChild(this.renderer.domElement);

                // 创建控制器
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 10;

                // 添加环境光
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);

                // 添加主光源
<!--                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);-->
<!--                directionalLight.position.set(-10, -10, 5);-->
<!--                directionalLight.castShadow = true;-->
<!--                directionalLight.shadow.mapSize.width = 2048;-->
<!--                directionalLight.shadow.mapSize.height = 2048;-->
<!--                this.scene.add(directionalLight);-->

                // 添加补充光源
                const pointLight = new THREE.PointLight(0xffffff, 0.3);
                pointLight.position.set(-10, -10, -5);
                this.scene.add(pointLight);

                // 添加半球光（模拟天空光）
                const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.3);
                this.scene.add(hemisphereLight);

                // 添加控制提示
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'model-controls';
                controlsDiv.innerHTML = '左键旋转 | 滚轮缩放 | 右键平移';
                this.container.appendChild(controlsDiv);

                // 启动渲染循环
                this.animate();

                // 监听窗口大小变化
                const handleResize = () => {
                    const newWidth = this.container.clientWidth;
                    const newHeight = this.container.clientHeight;
                    this.camera.aspect = newWidth / newHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(newWidth, newHeight);
                };
                window.addEventListener('resize', handleResize);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            async loadOBJModel(modelPath) {
                return new Promise((resolve, reject) => {
                    // 强制清除之前的模型
                    if (this.currentModel) {
                        this.scene.remove(this.currentModel);
                        this.currentModel = null;
                    }

                    // 显示加载状态
                    this.showStatus('loading', `🔄 加载新样本中...`);

                    // 处理文件路径
                    let finalPath = modelPath;
                    if (window.location.protocol === 'file:') {
                        finalPath = './' + modelPath;
                    }

                    console.log(`🎯 强制加载新OBJ文件: ${finalPath}`);

                    // 使用标准的THREE.OBJLoader
                    const loader = new THREE.OBJLoader();

                    loader.load(
                        finalPath,
                        // onLoad - 成功加载回调
                        (object) => {
                            console.log('✅ OBJ文件加载成功!');
                            this.processLoadedModel(object, modelPath);
                            this.showStatus('success', '✅ 3D模型加载完成!');
                            setTimeout(() => this.hideStatus(), 3000);
                            resolve(object);
                        },
                        // onProgress - 加载进度回调
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percentage = Math.round((progress.loaded / progress.total) * 100);
                                this.showStatus('loading', `🔄 加载进度: ${percentage}%`);
                                console.log('加载进度:', percentage + '%');
                            }
                        },
                        // onError - 错误回调
                        (error) => {
                            console.error('❌ OBJ文件加载失败:', error);
                            console.error('文件路径:', finalPath);

                            // 直接使用替代模型
                            this.showStatus('warning', '📦 使用3D替代模型');
                            this.createFallbackModel();

                            // 返回替代模型作为成功结果
                            setTimeout(() => resolve(this.currentModel), 1000);
                        }
                    );
                });
            }

            processLoadedModel(object, modelPath) {
                console.log('开始处理加载的OBJ模型...');

                // 清除之前的模型
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }

                // 统计模型信息
                let meshCount = 0;
                let vertexCount = 0;

                // 根据方法确定基础颜色
                let baseColor = 0x888888;
                if (modelPath.includes('affordpose')) baseColor = 0xe74c3c;
                else if (modelPath.includes('grabnet')) baseColor = 0x3498db;
                else if (modelPath.includes('ragg')) baseColor = 0x2ecc71;
                else if (modelPath.includes('sns')) baseColor = 0xf39c12;

                // 为模型添加材质和处理颜色
                object.traverse((child) => {
                    if (child.isMesh) {
                        meshCount++;

                        // 统计顶点数
                        if (child.geometry && child.geometry.attributes.position) {
                            vertexCount += child.geometry.attributes.position.count;
                        }

                        // 创建高质量材质 - 使用基础颜色但稍微偏向肉色
                        let materialColor = baseColor;
                        if (child.geometry && child.geometry.attributes.color) {
                            // 如果有顶点颜色，使用肉色调
                            materialColor = 0xfdbcb4; // 肉色
                        }

                        child.material = new THREE.MeshLambertMaterial({
                            color: materialColor,
                            transparent: false,
                            opacity: 1.0,
                            side: THREE.DoubleSide,
                            wireframe: false,
                            vertexColors: child.geometry.attributes.color ? true : false
                        });

                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                console.log(`模型统计 - 网格数: ${meshCount}, 顶点数: ${vertexCount}`);

                // 居中和缩放模型
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxSize = Math.max(size.x, size.y, size.z);
                console.log('模型尺寸:', size, '最大尺寸:', maxSize);

                if (maxSize > 0) {
                    const scale = 2.0 / maxSize;
                    object.scale.setScalar(scale);
                    object.position.copy(center).multiplyScalar(-scale);
                    console.log('模型缩放比例:', scale);
                } else {
                    // 如果无法计算尺寸，使用默认缩放
                    object.scale.setScalar(10);
                }

                // 添加到场景
                this.scene.add(object);
                this.currentModel = object;

                console.log('✅ OBJ模型处理完成并添加到场景');
            }

            showStatus(type, message) {
                let statusEl = this.container.querySelector('.model-status');
                if (!statusEl) {
                    statusEl = document.createElement('div');
                    statusEl.className = 'model-status';
                    this.container.appendChild(statusEl);
                }

                statusEl.className = `model-status status-${type}`;
                statusEl.textContent = message;
                statusEl.style.display = 'block';
            }

            hideStatus() {
                const statusEl = this.container.querySelector('.model-status');
                if (statusEl) {
                    statusEl.style.display = 'none';
                }
            }

            createFallbackModel() {
                // 清除之前的模型
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }

                // 创建方法颜色
                let methodColor = 0x888888;
                if (this.method === 'affordpose') methodColor = 0xe74c3c;
                else if (this.method === 'grabnet') methodColor = 0x3498db;
                else if (this.method === 'ragg') methodColor = 0x2ecc71;
                else if (this.method === 'sns') methodColor = 0xf39c12;

                const group = new THREE.Group();

                // 创建简化的手部模型
                // const handMaterial = new THREE.MeshPhongMaterial({ color: 0xfdbcb4 });
                const handMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbd0 });

                // 手掌
                const palmGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.5);
                const palm = new THREE.Mesh(palmGeometry, handMaterial);
                palm.position.set(0, 0, 0);
                group.add(palm);

                // 手指
                for (let i = 0; i < 5; i++) {
                    const fingerGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.2);
                    const finger = new THREE.Mesh(fingerGeometry, handMaterial);
                    finger.position.set(-0.12 + i * 0.06, 0.05, 0.35);
                    group.add(finger);
                }

                // 创建物体模型
                const cameraMaterial = new THREE.MeshPhongMaterial({ color: methodColor });

                // 物体主体
                const cameraBodyGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.2);
                const cameraBody = new THREE.Mesh(cameraBodyGeometry, cameraMaterial);

                if (currentMode === 'hold') {
                    cameraBody.position.set(0, 0.15, -0.1);
                    cameraBody.rotation.x = -Math.PI / 6;
                } else {
                    cameraBody.position.set(0.2, 0.1, 0.1);
                    cameraBody.rotation.y = Math.PI / 4;
                }

                group.add(cameraBody);

                // 镜头
                const lensGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.1);
                // const lensMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const lensMaterial = new THREE.MeshPhongMaterial({ color: 0x1a237e });
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);

                if (currentMode === 'hold') {
                    lens.position.set(0, 0.15, 0.05);
                    lens.rotation.x = Math.PI / 2;
                } else {
                    lens.position.set(0.35, 0.1, 0.1);
                    lens.rotation.z = Math.PI / 2;
                }

                group.add(lens);

                // 添加阴影
                group.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                this.scene.add(group);
                this.currentModel = group;

                if (window.location.protocol === 'file:') {
                    this.showStatus('success', `✨ ${this.method.toUpperCase()} 方法3D模型`);
                } else {
                    this.showStatus('error', `🟡 显示 ${this.method.toUpperCase()} 方法替代模型`);
                }

                // 5秒后隐藏状态
                setTimeout(() => {
                    this.hideStatus();
                }, 5000);
            }
        }

        // 初始化评估系统
        function initializeEvaluation() {
            samples = generateRandomSamples(20);
            currentSampleIndex = 0;
            evaluationResults = [];
            isEvaluationActive = false;

            showMessage('系统初始化完成！点击"开始评估"开始手-物体交互评估。', 'info');

            // 创建评估网格
            createEvaluationGrid();
        }

        // 创建评估网格
        function createEvaluationGrid() {
            const grid = document.getElementById('evaluationGrid');
            grid.innerHTML = '';

            methods.forEach(method => {
                const card = document.createElement('div');
                card.className = `method-card ${method}`;
                card.innerHTML = `
                    <div class="method-title">${method.toUpperCase()}</div>
                    <div class="model-viewer" id="viewer-${method}">
                        <div class="loading-spinner" style="display: none;"></div>
                    </div>
                    <div class="selection-checkbox">
                        <input type="checkbox" id="checkbox-${method}" onchange="handleMethodSelection('${method}')">
                        <label for="checkbox-${method}">选择</label>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        // 开始评估
        function startEvaluation() {
            if (samples.length === 0) {
                showMessage('请先初始化评估系统！', 'error');
                return;
            }

            isEvaluationActive = true;
            evaluationStartTime = Date.now();
            currentSampleIndex = 0;

            // 显示导航区域
            document.getElementById('navigationSection').style.display = 'block';

            // 启动计时器
            startTimer();

            // 加载第一个样本
            loadCurrentSample();

            showMessage('评估已开始！观察手-物体交互模型并选择表现最佳的方法。', 'success');
        }

        // 加载当前样本
        async function loadCurrentSample() {
            if (currentSampleIndex >= samples.length) {
                completeEvaluation();
                return;
            }

            const sampleId = samples[currentSampleIndex];
            const paddedId = String(sampleId).padStart(4, '0');
            console.log(`🔄 加载样本 ${sampleId} (${currentMode}模式)`);
            updateUI();
            
            // 清除之前的选择
            methods.forEach(method => {
                const checkbox = document.getElementById(`checkbox-${method}`);
                const card = checkbox.closest('.method-card');
                checkbox.checked = false;
                card.classList.remove('selected');
            });
            
            // 强制重新创建所有3D查看器，确保加载新模型
            window.viewers = {};
            
            // 为每个方法加载3D模型
            const promises = methods.map(async method => {
                const viewerId = `viewer-${method}`;
                const modelPath = `viz_mesh/${method}/${currentMode}/sample_${paddedId}.obj`;
                
                console.log(`🎯 正在加载 ${method} 样本 ${sampleId}:`, modelPath);
                
                // 每次都创建新的3D查看器
                if (!window.viewers) window.viewers = {};
                window.viewers[viewerId] = new Model3DViewer(viewerId, method);
                
                const viewer = window.viewers[viewerId];
                
                try {
                    await viewer.loadOBJModel(modelPath);
                    console.log(`✅ ${method} 样本 ${sampleId} 加载成功`);
                } catch (error) {
                    console.warn(`⚠️ ${method} 样本 ${sampleId} 加载失败，使用替代模型`);
                }
            });
            
            // 等待所有模型加载完成
            try {
                const results = await Promise.allSettled(promises);
                const failedCount = results.filter(r => r.status === 'rejected').length;
                
                if (failedCount === 0) {
                    showMessage(`🎉 样本 ${sampleId} (${currentMode}模式) 已加载完成！所有模型都是新的！`, 'success');
                } else if (failedCount === methods.length) {
                    if (window.location.protocol === 'file:') {
                        showMessage(`🔄 样本 ${sampleId} 已更新！使用3D替代模型显示`, 'info');
                    } else {
                        showMessage(`🔄 样本 ${sampleId} 已更新！使用替代模型显示`, 'warning');
                    }
                } else {
                    showMessage(`🔄 样本 ${sampleId} 已更新！部分使用替代模型`, 'warning');
                }
                
                // 让用户明确知道样本已经更换
                console.log(`✅ 样本切换完成！当前显示样本 ${sampleId}`);
                
            } catch (error) {
                showMessage(`❌ 样本 ${sampleId} 加载出错`, 'error');
            }
        }

        // 处理方法选择
        function handleMethodSelection(method) {
            const checkbox = document.getElementById(`checkbox-${method}`);
            const card = checkbox.closest('.method-card');
            
            if (checkbox.checked) {
                card.classList.add('selected');
                
                // 检查选择数量限制
                const selectedCount = document.querySelectorAll('.method-card.selected').length;
                if (selectedCount > 3) {
                    checkbox.checked = false;
                    card.classList.remove('selected');
                    showMessage('最多只能选择3个方法！', 'warning');
                }
            } else {
                card.classList.remove('selected');
            }
        }

        // 下一个样本
        function nextSample() {
            if (!isEvaluationActive) {
                showMessage('请先开始评估！', 'warning');
                return;
            }
            
            const selectedMethods = Array.from(document.querySelectorAll('.method-card.selected'))
                .map(card => card.classList[1]);
            
            if (selectedMethods.length === 0) {
                showMessage('请至少选择一个方法！', 'warning');
                return;
            }
            
            // 保存当前样本的评估结果
            const sampleId = samples[currentSampleIndex];
            evaluationResults.push({
                sampleId: sampleId,
                mode: currentMode,
                selectedMethods: selectedMethods,
                timestamp: new Date().toISOString(),
                evaluationTime: Date.now() - evaluationStartTime
            });
            
            currentSampleIndex++;
            loadCurrentSample();
        }

        // 上一个样本
        function previousSample() {
            if (currentSampleIndex > 0) {
                currentSampleIndex--;
                
                // 移除上一个样本的结果
                evaluationResults = evaluationResults.filter(result => 
                    result.sampleId !== samples[currentSampleIndex] || result.mode !== currentMode
                );
                
                loadCurrentSample();
            }
        }

        // 跳过样本
        function skipSample() {
            if (!isEvaluationActive) return;
            
            const sampleId = samples[currentSampleIndex];
            evaluationResults.push({
                sampleId: sampleId,
                mode: currentMode,
                selectedMethods: [],
                skipped: true,
                timestamp: new Date().toISOString(),
                evaluationTime: Date.now() - evaluationStartTime
            });
            
            currentSampleIndex++;
            loadCurrentSample();
            
            showMessage('样本已跳过', 'info');
        }

        // 切换模式
        function switchMode(mode) {
            if (currentMode === mode) return;
            
            currentMode = mode;
            
            // 更新模式按钮
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 如果评估活跃，重新加载当前样本
            if (isEvaluationActive) {
                loadCurrentSample();
            }
            
            showMessage(`已切换到 ${mode.toUpperCase()} 模式`, 'info');
        }

        // 更新UI
        function updateUI() {
            const sampleId = samples[currentSampleIndex];
            document.getElementById('currentSample').textContent = `样本 ID: ${sampleId}`;
            document.getElementById('sampleProgress').textContent = `(${currentSampleIndex + 1} / ${samples.length})`;
            document.getElementById('currentProgress').textContent = `${currentSampleIndex + 1}/${samples.length}`;
            document.getElementById('evaluatedCount').textContent = evaluationResults.length;
            
            const progress = (currentSampleIndex / samples.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        // 启动计时器
        function startTimer() {
            timerInterval = setInterval(() => {
                if (evaluationStartTime) {
                    const elapsed = Date.now() - evaluationStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('elapsedTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        // 完成评估
        function completeEvaluation() {
            isEvaluationActive = false;
            clearInterval(timerInterval);
            
            // 隐藏导航区域
            document.getElementById('navigationSection').style.display = 'none';
            
            // 显示结果
            showResults();
            
            showMessage('🎉 评估完成！查看下方的详细统计结果。', 'success');
        }

        // 显示结果
        function showResults() {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            
            // 计算统计数据
            const stats = calculateStatistics();
            
            // 创建图表
            createResultsChart(stats);
            
            // 显示详细统计
            displayDetailedStats(stats);
        }

        // 计算统计数据
        function calculateStatistics() {
            const methodStats = {};
            const modeStats = { hold: {}, use: {} };
            
            methods.forEach(method => {
                methodStats[method] = { total: 0, hold: 0, use: 0 };
                modeStats.hold[method] = 0;
                modeStats.use[method] = 0;
            });
            
            evaluationResults.forEach(result => {
                if (!result.skipped) {
                    result.selectedMethods.forEach(method => {
                        methodStats[method].total++;
                        methodStats[method][result.mode]++;
                        modeStats[result.mode][method]++;
                    });
                }
            });
            
            return { methodStats, modeStats };
        }

        // 创建结果图表
        function createResultsChart(stats) {
            const ctx = document.getElementById('resultsChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: methods.map(m => m.toUpperCase()),
                    datasets: [
                        {
                            label: 'Hold 模式选择次数',
                            data: methods.map(method => stats.modeStats.hold[method]),
                            backgroundColor: 'rgba(102, 126, 234, 0.8)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Use 模式选择次数',
                            data: methods.map(method => stats.modeStats.use[method]),
                            backgroundColor: 'rgba(118, 75, 162, 0.8)',
                            borderColor: 'rgba(118, 75, 162, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            stepSize: 1
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '各方法在不同模式下的选择统计'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // 显示详细统计
        function displayDetailedStats(stats) {
            const detailedStats = document.getElementById('detailedStats');
            
            let html = '<h3>详细统计数据</h3>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">';
            
            methods.forEach(method => {
                const methodStat = stats.methodStats[method];
                const percentage = ((methodStat.total / evaluationResults.filter(r => !r.skipped).length) * 100).toFixed(1);
                
                html += `
                    <div style="background: ${methodColors[method]}20; padding: 15px; border-radius: 10px; border-left: 4px solid ${methodColors[method]};">
                        <h4 style="color: ${methodColors[method]}; margin-bottom: 10px;">${method.toUpperCase()}</h4>
                        <p>总选择次数: <strong>${methodStat.total}</strong></p>
                        <p>Hold模式: <strong>${methodStat.hold}</strong></p>
                        <p>Use模式: <strong>${methodStat.use}</strong></p>
                        <p>选择率: <strong>${percentage}%</strong></p>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // 添加评估概览
            const totalEvaluated = evaluationResults.filter(r => !r.skipped).length;
            const totalSkipped = evaluationResults.filter(r => r.skipped).length;
            const avgSelections = (evaluationResults.filter(r => !r.skipped).reduce((sum, r) => sum + r.selectedMethods.length, 0) / totalEvaluated).toFixed(1);
            
            html += `
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h4>评估概览</h4>
                    <p>总样本数: <strong>${samples.length}</strong></p>
                    <p>已评估: <strong>${totalEvaluated}</strong></p>
                    <p>已跳过: <strong>${totalSkipped}</strong></p>
                    <p>平均每样本选择方法数: <strong>${avgSelections}</strong></p>
                    <p>评估总时长: <strong>${document.getElementById('elapsedTime').textContent}</strong></p>
                </div>
            `;
            
            detailedStats.innerHTML = html;
        }

        // 导出结果
        function exportResults(format) {
            if (evaluationResults.length === 0) {
                showMessage('没有可导出的评估结果！', 'warning');
                return;
            }
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const filename = `hand_camera_interaction_evaluation_${timestamp}`;
            
            if (format === 'json') {
                const data = {
                    metadata: {
                        evaluationDate: new Date().toISOString(),
                        totalSamples: samples.length,
                        evaluatedSamples: evaluationResults.filter(r => !r.skipped).length,
                        skippedSamples: evaluationResults.filter(r => r.skipped).length,
                        modes: ['hold', 'use'],
                        methods: methods,
                        sampleRange: '0-176'
                    },
                    samples: samples,
                    results: evaluationResults,
                    statistics: calculateStatistics()
                };
                
                downloadJSON(data, `${filename}.json`);
            } else if (format === 'csv') {
                const csvContent = generateCSV();
                downloadCSV(csvContent, `${filename}.csv`);
            }
            
            showMessage(`评估结果已导出为 ${format.toUpperCase()} 格式！`, 'success');
        }

        // 生成CSV内容
        function generateCSV() {
            let csv = 'Sample ID,Mode,Selected Methods,Skipped,Timestamp,Evaluation Time (ms)\n';
            
            evaluationResults.forEach(result => {
                const selectedMethods = result.selectedMethods.join(';');
                csv += `${result.sampleId},${result.mode},"${selectedMethods}",${result.skipped || false},${result.timestamp},${result.evaluationTime}\n`;
            });
            
            return csv;
        }

        // 下载JSON文件
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 下载CSV文件
        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 重置评估
        function resetEvaluation() {
            if (isEvaluationActive && !confirm('确定要重置当前评估吗？所有进度将丢失！')) {
                return;
            }
            
            // 清理状态
            isEvaluationActive = false;
            clearInterval(timerInterval);
            currentSampleIndex = 0;
            evaluationResults = [];
            evaluationStartTime = null;
            
            // 重置UI
            document.getElementById('navigationSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('currentProgress').textContent = '0';
            document.getElementById('evaluatedCount').textContent = '0';
            document.getElementById('elapsedTime').textContent = '00:00';
            document.getElementById('progressFill').style.width = '0%';
            
            // 清除选择
            document.querySelectorAll('.method-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // 重新初始化
            initializeEvaluation();
            
            showMessage('评估已重置！可以重新开始评估。', 'info');
        }

        // 显示消息
        function showMessage(text, type = 'info') {
            const container = document.getElementById('messageContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            
            container.innerHTML = '';
            container.appendChild(messageDiv);
            
            // 5秒后自动隐藏
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // 显示帮助
        function showHelp() {
            document.getElementById('helpModal').style.display = 'block';
        }

        // 关闭帮助
        function closeHelp() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // 键盘快捷键
        document.addEventListener('keydown', function(event) {
            if (!isEvaluationActive) return;
            
            switch(event.key) {
                case ' ':
                    event.preventDefault();
                    nextSample();
                    break;
                case 's':
                case 'S':
                    event.preventDefault();
                    skipSample();
                    break;
                case 'h':
                case 'H':
                    event.preventDefault();
                    switchMode('hold');
                    break;
                case 'u':
                case 'U':
                    event.preventDefault();
                    switchMode('use');
                    break;
                case 'r':
                case 'R':
                    event.preventDefault();
                    resetEvaluation();
                    break;
                case '?':
                    event.preventDefault();
                    showHelp();
                    break;
            }
        });

        // 模态框点击外部关闭
        window.onclick = function(event) {
            const modal = document.getElementById('helpModal');
            if (event.target === modal) {
                closeHelp();
            }
        }





        // 页面加载完成后运行诊断
        document.addEventListener('DOMContentLoaded', function() {
            runSystemDiagnostics();
            initializeEvaluation();
        });

        // 系统诊断功能
        async function runSystemDiagnostics() {
            console.log('🔍 开始系统诊断...');
            
            // 检查Three.js加载状态
            if (typeof THREE !== 'undefined') {
                console.log('✅ Three.js库加载成功');
                showMessage('✅ Three.js引擎加载成功', 'success');
            } else {
                console.error('❌ Three.js库加载失败');
                showMessage('❌ Three.js引擎加载失败', 'error');
                return;
            }
            
            // 检查OBJ加载器
            if (typeof THREE.OBJLoader !== 'undefined') {
                console.log('✅ OBJLoader加载成功');
            } else {
                console.error('❌ OBJLoader加载失败');
                showMessage('❌ OBJ加载器无法使用', 'error');
                return;
            }
            
            // 检查轨道控制器
            if (typeof THREE.OrbitControls !== 'undefined') {
                console.log('✅ OrbitControls加载成功');
            } else {
                console.error('❌ OrbitControls加载失败');
                showMessage('❌ 3D控制器无法使用', 'warning');
            }
            
            // 测试OBJ文件访问
            await testOBJAccess();
            
            console.log('🎯 系统诊断完成');
        }

        // 测试OBJ文件访问
        async function testOBJAccess() {
            const testFile = 'viz_mesh/affordpose/hold/sample_2065.obj';
            
            try {
                console.log('🔍 测试OBJ文件访问:', testFile);
                
                const response = await fetch(testFile);
                if (response.ok) {
                    const text = await response.text();
                    if (text.length > 100 && text.includes('v ')) {
                        console.log('✅ OBJ文件访问测试通过！');
                        showMessage('✅ OBJ文件访问测试通过！可以正常加载3D模型', 'success');
                        return true;
                    } else {
                        console.log('⚠️ OBJ文件格式异常');
                        showMessage('⚠️ OBJ文件格式可能有问题', 'warning');
                    }
                } else {
                    console.log('❌ OBJ文件访问失败:', response.status);
                    showMessage('🟡 OBJ文件访问受限，将使用3D替代模型', 'info');
                }
            } catch (error) {
                console.log('❌ OBJ文件访问错误:', error.message);
                if (window.location.protocol === 'file:') {
                    showMessage('🌟 直接文件模式启动成功！系统将使用智能3D模型显示', 'info');
                } else {
                    showMessage('🟡 使用3D替代模型确保评估功能正常', 'info');
                }
            }
            return false;
        }
    </script>
</body>
</html> 
